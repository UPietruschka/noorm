package org.noorm.platform.postgresql;

import org.noorm.jdbc.FilterExtension;
import org.noorm.jdbc.QueryColumn;
import org.noorm.jdbc.StatementBuilder;
import org.noorm.jdbc.platform.IMetadata;
import org.noorm.jdbc.platform.IPlatform;
import org.postgresql.ds.PGSimpleDataSource;

import javax.sql.DataSource;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Map;

/**
 * @author Ulf Pietruschka / ulf.pietruschka@etenso.com
 *         Date: 11.02.17
 *         Time: 13:52
 */
public class PostgresqlPlatform implements IPlatform {

    private static final String POSTGRESQL_PLATFORM = "Postgresql";

    private final PostgresqlMetadata postgresqlMetadata = new PostgresqlMetadata();
    private final StatementBuilder statementBuilder = new StatementBuilder();

    /**
     * Returns the name of platform service provider
     *
     * @return the platform name
     */
    @Override
    public String getName() {

        return POSTGRESQL_PLATFORM;
    }

    /**
     * Creates a platform specific data source.
     *
     * @param pURL the connection URL
     * @param pUsername the username
     * @param pPassword the password
     * @return the established data source
     */
    @Override
    public DataSource getDataSource(String pURL, String pUsername, String pPassword) throws SQLException {

        final PGSimpleDataSource dataSource = new PGSimpleDataSource();
        dataSource.setURL(pURL);
        dataSource.setUser(pUsername);
        dataSource.setPassword(pPassword);
        return dataSource;
    }

    /**
     * Validates the platform specific data source
     *
     * @param pDataSource the data source
     * @return a textual summary of the data source validation
     */
    @Override
    public String validateDataSource(DataSource pDataSource) throws SQLException {

        final StringBuilder validationInfo = new StringBuilder();
        validationInfo.append("Validating data source. ");
        if (pDataSource instanceof PGSimpleDataSource) {
            validationInfo.append("Connection parameters: ");
            validationInfo.append(";URL: ");
            validationInfo.append(((PGSimpleDataSource) pDataSource).getURL());
            validationInfo.append(";Username: ");
            validationInfo.append(((PGSimpleDataSource) pDataSource).getUser());
        } else {
            validationInfo.append("Unable to retrieve connection parameters from data source. [");
            validationInfo.append(pDataSource.getClass().getName());
            validationInfo.append("]");
        }
        return validationInfo.toString();
    }

    /**
     * Returns the platform specific query to retrieve a sequence value generated by the database.
     *
     * @param pSequenceName the name of the database sequence
     * @return the SELECT statement to retrieve a single sequence value for the given platform
     */
    @Override
    public String getSequenceQuery(final String pSequenceName) {

        final String sequenceQuery = "SELECT NEXTVAL ('".concat(pSequenceName).concat("')");
        return sequenceQuery;
    }

    /**
     * Executes a batch over a prepared statement.
     * Different databases and JDBC drivers handle the update count differently. To get a reliable update,
     * a platform specific implementation is required.
     *
     * @param pPreparedStatement the prepared statement ready for executing the next batch
     * @return the reliable update count for the platform in use
     */
    @Override
    public int executeBatchWithReliableCount(final PreparedStatement pPreparedStatement) throws SQLException {

        final int[] batchCounts = pPreparedStatement.executeBatch();
        int updateCount = 0;
        for (int i = 0; i < batchCounts.length; i++) {
            updateCount += batchCounts[i];
        }
        return updateCount;
    }

    /**
     * Sets an object value for an DML statement (INSERT, UPDATE, DELETE).
     *
     * @param pStmt           the prepared SQL statement
     * @param pValue          the parameter value to be set
     * @param pParameterIndex the index of the parameter
     * @param pSQLType        the SQL type. Usually one type specified in java.sql.Types or a proprietary type
     * @throws SQLException JDBC driver exception
     */
    @Override
    public void setObject(final PreparedStatement pStmt,
                          final Object pValue,
                          final int pParameterIndex,
                          final int pSQLType) throws SQLException {

        if (pValue == null) {
            pStmt.setNull(pParameterIndex, pSQLType);
        } else {
            if (pSQLType == -1) {
                pStmt.setObject(pParameterIndex, pValue);
            } else {
                pStmt.setObject(pParameterIndex, pValue, pSQLType);
            }
        }
    }

    /**
     * Binds a numeric array to a callable statement.
     *
     * @param pCon            the JDBC connection
     * @param pCstmt          the JDBC callable statement
     * @param pValue          the value to bind (numeric array)
     * @param pParameterIndex the parameter index
     * @throws java.sql.SQLException JDBC driver exception
     */
    @Override
    public void prepareNumericArray(Connection pCon, CallableStatement pCstmt, Object pValue, int pParameterIndex) throws SQLException {

        throw new UnsupportedOperationException();
    }

    /**
     * Constructs a SQL query based on the provided information.
     *
     * NOTE: FilterExtension functionality NOT YET IMPLEMENTED!
     *
     * @param pTableName          the table name
     * @param pInParameters       the query parameters
     * @param pUseNamedParameters whether to use named parameters or not
     * @param pAcquireLock        lock the retrieved data for further processing
     * @param pFilterExtension    paging and sorting information
     * @return the constructed SQL query
     */
    @Override
    public String buildSQLStatement(final String pTableName,
                                    final Map<QueryColumn, Object> pInParameters,
                                    final boolean pUseNamedParameters,
                                    final boolean pAcquireLock,
                                    final FilterExtension pFilterExtension) {

        final String baseQuery =
                statementBuilder.buildSQLStatement(pTableName, pInParameters, pUseNamedParameters, pAcquireLock);
        if (pFilterExtension == null) {
            return baseQuery;
        }
        return baseQuery;
    }

    /**
     * Provides database metadata for code generation and validation of generated code.
     *
     * @return the platform specific implementation of the metadata retrieval functionality
     */
    @Override
    public IMetadata getMetadata() {

        return postgresqlMetadata;
    }
}
