package org.noorm.platform.oracle;

import oracle.jdbc.OracleConnection;
import oracle.jdbc.OraclePreparedStatement;
import oracle.jdbc.pool.OracleDataSource;
import org.noorm.jdbc.*;
import org.noorm.jdbc.platform.IMetadata;
import org.noorm.jdbc.platform.IPlatform;

import javax.sql.DataSource;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.Properties;

/**
 * @author Ulf Pietruschka / ulf.pietruschka@etenso.com
 *         Date: 11.02.14
 *         Time: 13:52
 */
public class OraclePlatform implements IPlatform {

    public static final String ORACLE_PLATFORM = "Oracle";

    private static final int ORACLE_REF_CURSOR_JDBC_TYPE = -10;

    private final OracleMetadata oracleMetadata = OracleMetadata.getInstance();
    private final StatementBuilder statementBuilder = new StatementBuilder();

    /**
     * Returns the name of platform service provider
     *
     * @return the platform name
     */
    @Override
    public String getName() {

        return ORACLE_PLATFORM;
    }

    /**
     * Creates a platform specific data source.
     *
     * @param pURL the connection URL
     * @param pUsername the username
     * @param pPassword the password
     * @return the established data source
     */
    @Override
    public DataSource getDataSource(String pURL, String pUsername, String pPassword) throws SQLException {

		final OracleDataSource oracleDataSource = new OracleDataSource();
		oracleDataSource.setURL(pURL);
		oracleDataSource.setUser(pUsername);
		oracleDataSource.setPassword(pPassword);

        // We enable the Oracle connection cache integrated with the Oracle JDBC driver.
        // Even for single-threaded stand-alone applications using a connection pool/cache makes sense.
        // Like any other ORM tool, NoORM does not manage data sources, but simply uses the JDBC API.
        // When transactions are not handled explicitly by the calling application, the implicit
        // auto-commit mode will cause connections to be closed with every single database call. Though
        // DataSourceProvider could retain connections for some time, its primary function is not the
        // maintenance of a connection cache or pool, so this job is delegated to the used data source,
        // which should provide some caching functionality for any usage scenario.
        // Unfortunately, Oracle stopped development of the build-in connection cache, so, starting with
        // Oracle 11.2, the build-in cache is deprecated. We still use it here, since explicit data source
        // initialization as performed here is not to be used in production systems anyway.

        /* The connection cache is deprecated starting from Oracle 11g and completely removed in 21c
        oracleDataSource.setConnectionCachingEnabled(true);
        Properties cacheProps = new Properties();
        cacheProps.setProperty("MinLimit", "1");
        cacheProps.setProperty("MaxLimit", "8");
        cacheProps.setProperty("InitialLimit", "1");
        oracleDataSource.setConnectionCacheProperties(cacheProps);
        */

        return oracleDataSource;
    }

    /**
     * Validates the platform specific data source
     *
     * @param pDataSource the data source
     * @return a textual summary of the data source validation
     */
    @Override
    public String validateDataSource(final DataSource pDataSource) throws SQLException {

        final StringBuilder validationInfo = new StringBuilder();
        validationInfo.append("Validating data source. ");
        if (pDataSource instanceof OracleDataSource) {
            final Properties connectionProperties = new Properties();
            connectionProperties.setProperty(OracleConnection.CONNECTION_PROPERTY_FIXED_STRING, "true");
            connectionProperties.setProperty(OracleConnection.CONNECTION_PROPERTY_INCLUDE_SYNONYMS, "true");
            ((OracleDataSource) pDataSource).setConnectionProperties(connectionProperties);
            validationInfo.append("Connection parameters: ");
            validationInfo.append(";Data Source Implementation: ");
            validationInfo.append(pDataSource.getClass().getName());
            validationInfo.append(";URL: ");
            validationInfo.append(((OracleDataSource) pDataSource).getURL());
            validationInfo.append(";Username: ");
            validationInfo.append(((OracleDataSource) pDataSource).getUser());
        } else {
            validationInfo.append("Unable to retrieve connection parameters from data source. [");
            validationInfo.append(pDataSource.getConnection().getClass().getName());
            validationInfo.append("]");
        }
        return validationInfo.toString();
    }

    /**
     * Returns the platform specific query to retrieve a sequence value generated by the database.
     *
     * @param pSequenceName the name of the database sequence
     * @return the SELECT statement to retrieve a single sequence value for the given platform
     */
    @Override
    public String getSequenceQuery(final String pSequenceName) {

        final String sequenceQuery = "SELECT ".concat(pSequenceName).concat(".NEXTVAL FROM DUAL");
        return sequenceQuery;
    }

    /**
     * Executes a batch over a prepared statement.
     * Different databases and JDBC drivers handle the update count differently. To get a reliable update,
     * a platform specific implementation is required.
     *
     * @param pPreparedStatement the prepared statement ready for executing the next batch
     * @return the reliable update count for the platform in use
     */
    @Override
    public int executeBatchWithReliableCount(final PreparedStatement pPreparedStatement) throws SQLException {

        pPreparedStatement.executeBatch();
        return pPreparedStatement.getUpdateCount();
    }

    /**
     * Sets an object value for an DML statement (INSERT, UPDATE, DELETE).
     *
     * @param pStmt           the prepared SQL statement
     * @param pValue          the parameter value to be set
     * @param pParameterIndex the index of the parameter
     * @param pSQLType        the SQL type. Usually one type specified in java.sql.Types or a proprietary type
     * @throws SQLException JDBC driver exception
     */
    @Override
    public void setObject(final PreparedStatement pStmt,
                          final Object pValue,
                          final int pParameterIndex,
                          final int pSQLType) throws SQLException {

        if (pValue instanceof String) {
            // SQL CHAR comparison semantics by default uses padding, which causes some
            // confusion, since it does not even matter, whether the data has initially been
            // provided with or without padding. Using the following proprietary method
            // disabled this behaviour and turns off padding.
            ((OraclePreparedStatement) pStmt).setFixedCHAR(pParameterIndex, (String) pValue);
        } else {
            pStmt.setObject(pParameterIndex, pValue);
        }
    }

    /**
     * The REF_CURSOR JDBC type is used to directly utilize a SQL cursor established from within
     * a stored procedure for a JDBC ResultSet. However, though we have JDBCType.REF_CURSOR, this
     * does not necessarily match the vendor type, so we can provide the vendor type here.
     *
     * @return the REF_CURSOR JDBC type
     */
    @Override
    public int getRefCursorJDBCType() {
        return ORACLE_REF_CURSOR_JDBC_TYPE;
    }

    private static final String BASE_QUERY_PLACEHOLDER = "__BASE_QUERY__";
    private static final String TOTAL_LIMIT_PLACEHOLDER = "__TOTAL_LIMIT__";
    private static final String COUNT_PLACEHOLDER = "__COUNT__";
    private static final String STARTROW_PLACEHOLDER = "__STARTROW__";
    private static final String ENDROW_PLACEHOLDER = "__ENDROW__";
    private static final String ORDERBY_PLACEHOLDER = "__ORDERBY__";
    private static final String ORACLE_PAGING_WRAPPER =
            "SELECT /*+ first_rows(" + COUNT_PLACEHOLDER + ") */ * FROM "
          + "(SELECT WRAPPED.*, ROWNUM pos, COUNT(*) OVER() " + IBean.PAGING_TOTAL + " FROM "
          + "(" + BASE_QUERY_PLACEHOLDER + ORDERBY_PLACEHOLDER + ") WRAPPED " + TOTAL_LIMIT_PLACEHOLDER + ") "
          + "WHERE pos BETWEEN " + STARTROW_PLACEHOLDER + " AND " + ENDROW_PLACEHOLDER;

    private static final String ORDER_BY_CLAUSE = " ORDER BY ";
    private static final String TOTAL_LIMIT_CLAUSE = " WHERE ROWNUM <= ";

    /**
     * Constructs a SQL query based on the provided information.
     *
     * @param pTableName          the table name
     * @param pInParameters       the query parameters
     * @param pUseNamedParameters whether to use named parameters or not
     * @param pAcquireLock        lock the retrieved data for further processing
     * @param pFilterExtension    paging and sorting information
     * @return the constructed SQL query
     */
    @Override
    public String buildSQLStatement(final String pTableName,
                                    final Map<QueryColumn, Object> pInParameters,
                                    final boolean pUseNamedParameters,
                                    final boolean pAcquireLock,
                                    final FilterExtension pFilterExtension) {

        final String baseQuery =
                statementBuilder.buildSQLStatement(pTableName, pInParameters, pUseNamedParameters, pAcquireLock);
        if (pFilterExtension == null) {
            return baseQuery;
        }
        String statement = ORACLE_PAGING_WRAPPER;
        statement = statement.replace(BASE_QUERY_PLACEHOLDER, baseQuery);
        final Integer totalLimit = pFilterExtension.getTotalLimit();
        if (totalLimit != null && totalLimit > 0) {
            statement = statement.replace(TOTAL_LIMIT_PLACEHOLDER, TOTAL_LIMIT_CLAUSE + totalLimit + " ");
        } else {
            statement = statement.replace(TOTAL_LIMIT_PLACEHOLDER, "");
        }
        statement = statement.replace(COUNT_PLACEHOLDER, Integer.toString(pFilterExtension.getLimit()));
        // Oracle rownum starts from "1", we want offset to start from "0", so we add "1" to the offset.
        final int offset0 = pFilterExtension.getOffset() + 1;
        statement = statement.replace(STARTROW_PLACEHOLDER, Integer.toString(offset0));
        final int endRow = offset0 + pFilterExtension.getLimit() - 1;
        statement = statement.replace(ENDROW_PLACEHOLDER, Integer.toString(endRow));
        final List<FilterExtension.SortCriteria> sortCriterias = pFilterExtension.getSortCriteria();
        if (sortCriterias.size() > 0) {
            String orderByClause = "";
            String delimiter = ORDER_BY_CLAUSE;
            for (final FilterExtension.SortCriteria sortCriteria : sortCriterias) {
                final String columnName = sortCriteria.getColumnName();
                if (columnName == null) {
                    throw new DataAccessException(DataAccessException.Type.ILLEGAL_SORT_CRITERIA);
                }
                orderByClause += delimiter + columnName + " " + sortCriteria.getDirection();
                delimiter = ", ";
            }
            statement = statement.replace(ORDERBY_PLACEHOLDER, orderByClause);
        } else {
            statement = statement.replace(ORDERBY_PLACEHOLDER, "");
        }
        return statement;
    }

    /**
     * Provides database metadata for code generation and validation of generated code.
     *
     * @return the platform specific implementation of the metadata retrieval functionality
     */
    @Override
    public IMetadata getMetadata() {

        return oracleMetadata;
    }
}
