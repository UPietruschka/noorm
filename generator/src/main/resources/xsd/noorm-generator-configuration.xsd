<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns="http://www.noorm.org/generator-configuration/1.0.0"
           targetNamespace="http://www.noorm.org/generator-configuration/1.0.0"
           elementFormDefault="qualified"
           attributeFormDefault="unqualified">

    <xs:element name="generatorConfiguration">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="beanPackage" type="name">
                    <xs:annotation>
                        <xs:documentation>
                            Java package name for generated Bean source files.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="enumPackage" type="name" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Java package name for generated Enum source files.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="servicePackage" type="name">
                    <xs:annotation>
                        <xs:documentation>
                            Java package name for generated Service / DAO source files.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="serviceInterfacePackage" type="name" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Services, resp. DAOs generated by NoORM are singletons. By default, the services
                            or DAOs are instantiated right after class loading and provided by the class method
                            "getInstance".
                            Alternatively, class instantiation can be delegated to a dependency injection framework
                            like Spring. By specifying parameter serviceInterfacePackageName, the service generator
                            is directed to omit the in-class singleton implementation and generate appropriate
                            interfaces for every service, resp. DAO in the given package.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="beanTableFilter" type="regex" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Regular expression to filter tables and views for Bean generation.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="enumTableFilter" type="regex" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Regular expression to filter tables and views for Enum generation.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="packageFilter" type="regex" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Regular expression to filter (database) packages for service generation.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="table2SequenceMappings" type="mappingList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Primary key generation for new records being inserted into the database can be based
                            on a numeric ID column and an sequence. Sequences are not tied to a table
                            by definition, so associating a table with a sequence is done using this property
                            list. Note that the association TABLE_NAME/SEQUENCE_NAME can either be done on a per
                            table basis, or using one or more regular expressions to specify a mapping rule like
                            "TBL_(.*)" -> "SEQ_$1" (This rule would map TBL_PRODUCT to SEQ_PRODUCT, for example).
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="inlineSequenceTableFilter" type="regex" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Regular expression to filter tables and views for inline sequence value generation.
                            When sequences are used to generate primary key values for tables, the sequence
                            values are retrieved from the database using a separate SQL statement. This is
                            the most flexible approach concerning performance for bulk inserts and the provision
                            of the generated values for the application (i.e., the beans subject to insertion
                            are modified by setting the primary key values on the fly).
                            However, for tables typically having single inserts only (no bulk inserts) with a
                            sequence increment of 1, it can be preferable to inline the sequence generation to
                            avoid the extra database round-trip to get the next sequence value. For single
                            row inserts, NoORM can return the updated bean (primary key value), too.
                            This parameters allows for a flexible specification of the beans / tables subject to
                            inline sequence value generation using a regular expression.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="tableNameMappings" type="mappingList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The default naming scheme for the generated classes follows standards and conventions
                            for names used in databases and names used for Java classes.
                            While database names are usually in upper-case, using the underscore as delimiter
                            between parts of the name (e.g. "ORDER_DETAIL"), Java names use a capitalized first
                            character of the name part without delimiter instead (e.g. "OrderDetail").
                            This parameter can be used to override this mechanism by specifying a regular expression
                            for the mapping between the database name and the Java name.
                            This setting applies to the bean generator and the enum generator.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="columnNameMappings" type="mappingList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The default naming scheme for the generated attributes follows standards and conventions
                            for names used in databases and names used for Java classes.
                            While database names are usually in upper-case, using the underscore as delimiter
                            between parts of the name (e.g. "ORDER_ID"), Java names use a capitalized first
                            character of the name part without delimiter instead (e.g. "OrderId").
                            This parameter can be used to override this mechanism by specifying a regular expression
                            for the mapping between the database name and the Java name.
                            This setting applies to the bean generator and the enum generator.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="enumTable2DisplayColumnMappings" type="mappingList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            To generate Enums from database tables, NoORM must now, which table column should be
                            used for the enums constant type generation. Typically, a table with constant content
                            has a column with a code or denominator in uppercase letters, which uniquely
                            identifies the row.
                            Use this parameter to map tables, resp. views to this column name.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="optLockVersionColumnMappings" type="mappingList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Concurrency control can be based on optimistic locking. To identify the version column,
                            a mapping from the table-name to the version column should be specified. Dependent on
                            how specific the column-names are with respect to the table-names, one or more
                            mappings are required. In case of a unique name of the version column for all tables,
                            one simple rule like ".*" -> "VERSION" is sufficient.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="optLockFullRowCompareTableFilter" type="regex" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Concurrency control can be based on optimistic locking.
                            When no version column is available for the tables subject to optimistic locking,
                            the complete pre-change image of the row is used to determine database changes, which
                            have occurred in the meantime. The tables listed here are subject to this type of
                            optimistic locking.
                            (Do not use both available types of optimistic locking simultaneously).
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="viewName2PrimaryKeyMappings" type="mappingList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The database metadata does not provide unambiguous information for the primary
                            key of a view (for tables, this information is available). When the intended use of a
                            view includes DML operations (which requires the view to contain one and only one
                            key-preserved table) or data access with the PageableBeanList, NoORM needs a key to
                            uniquely distinguish the records of this view.
                            Use this parameter to specify the column name of the key used for a given view.
                            Typically, this key is the primary key of the single key-preserved table contained in
                            the view definition.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="singleRowFinder" type="regex" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Using the signature of a stored procedure to generate code does not provide any hint,
                            if the returned data is limited to a single row (which in turn changes
                            the signature of the generated Java code, instead of a List a single Bean is returned).
                            Use this parameter to specify a regular expression matching all procedure names
                            subject to single row retrieval.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="pageableProcedureName" type="regex" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Large query results can be mapped into a PageableBeanList to provide efficient
                            access to the data by loading the full record only for the requested page.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="extendedBeans" type="mappingList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Beans generated from database entities are often subject to data enrichment in
                            the service layer utilizing the bean data. One option to add additional data to
                            the bean is the generic (generated) bean property "auxiliaryData". However, some
                            data consumers may require data provided in a flat bean without nested data
                            (i.e., the additional data is available using standard bean properties).
                            As an alternative approach to the auxiliary data property, the user may create
                            a subclass for the generated bean with additional bean properties. To utilize
                            this inherited bean classes, the generated services using the originally generated
                            class should use the subclass. This parameter allows to replace occurrences of the
                            originally generated bean classes in the generated services/DAOs with the subclass.
                            Note that the subclass must be fully classified.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="generatePKBasedEqualsAndHashCode" type="xs:boolean" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The implementation of methods "equals" and "hashCode" for the generated beans raises
                            the same questions intensively discussed for JPA entities. In particular, three options
                            are available: do not implement these methods at all, implement them based on the
                            technical ID, i.e. the primary key, or implement them based on some business-id.
                            The latter is not applicable for generated code, since we do not have the required
                            insight into the semantics of the bean/table to decide on a business-id.
                            Thus, options one and two remain and this option can be used to choose one. Note that
                            this option is set to true by default (i.e. methods equals and hashCode are
                            automatically implemented based on the primary key).
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="dataSource" type="name" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            When multiple data sources are used, the data source name as configured in the NoORM
                            configuration file is used to identify different data sources. To specify the data
                            source used for the subsequent statements, one can either set the data source explicitly
                            using DataSourceProvider.setActiveDataSource, or one can specify the data source name
                            here. Note that for explicit transaction handling, one still have to specify the data
                            source name.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="queryDeclarations" type="queryDeclarations" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The NoORM query declaration is intentionally much simpler than most other approaches
                            to specify alternatives to original SQL. While specifications like the JPA 2.0 criteria
                            API aim to cover most of the capabilities of SQL, this approach consequently follows
                            the paradigm to move database-centric functionality to the database.
                            In particular, this means that the complexity of an SQL statement should be implemented
                            inside the database using views. Following this approach, it is almost always possible
                            to reduce the query declaration for automatic Java code generation to a single entity
                            (table, view), the columns subject to the where-conditions (concatenated by "AND") and
                            the operators used for the columns in the where-conditions.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="typeMappings" type="typeMappings" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The Java code generator defines for every database type a default Java type, which is used in
                            the generated classes for attributes and method parameters (e.g. NUMBER -> java.lang.Long).
                            However, this mapping may not be suitable for certain situations. This configuration parameter
                            provides a flexible way to define custom type mappings.
                            Note that the database type depends on the database system and is not checked for validity, but
                            simply compared against the database types as retrieved from the database metadata. So, an
                            invalid database type has simply no effect.
                            The specified Java type however is checked for existence by the code generator, but not for
                            validity with respect to a proper data conversion in the JDBC driver used.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="name">
        <xs:attribute name="name" use="required" type="xs:string">
            <xs:annotation>
                <xs:documentation>
                    Generic attribute for names.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="regex">
        <xs:attribute name="regex" use="required" type="xs:string">
            <xs:annotation>
                <xs:documentation>
                    Generic attribute for regular expressions.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="mappingList">
        <xs:sequence>
            <xs:element name="mapping" type="mapping" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="mapping">
        <xs:annotation>
            <xs:documentation>
                Generic mapping element.
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="key" use="required" type="xs:string"/>
        <xs:attribute name="value" use="required" type="xs:string"/>
    </xs:complexType>

    <xs:complexType name="queryDeclarations">
        <xs:annotation>
            <xs:documentation>
                A list of automatically generated query declarations.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="queryDeclaration" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="queryDeclaration">
        <xs:annotation>
            <xs:documentation>
                Query declarations provide a convenient and simple way to specify SQL queries without the need
                to explicitly write SQL code. However, query declarations are not designated to replace SQL code
                of arbitrary complexity, but only to provide an efficient method to specify rather primitive SQL
                queries using a single entity only and a list of WHERE conditions concatenated by "AND".
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="queryColumn" type="queryColumn" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="tableName" use="required" type="xs:string">
                <xs:annotation>
                    <xs:documentation>
                        The name of the database entity (table or view) to query against.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="baseTable" type="xs:string">
                <xs:annotation>
                    <xs:documentation>
                        The name of the database entity (table or view), which is the base for the returning
                        type. When parameter "tableName" is a view, the desired return type may be only one of
                        the tables contained in the view.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="methodName" type="xs:string">
                <xs:annotation>
                    <xs:documentation>
                        The (Java) method name for the generated code (if omitted, NoORM automatically
                        generates a method name. This is typically suitable, if not too many query columns
                        are defined. For many query columns, manual method name specification if preferable).
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="className" type="xs:string">
                <xs:annotation>
                    <xs:documentation>
                        The name of the Java class to be generated (Optional, by default NoORM generates one
                        single class named "DeclaredQueries" for all declared queries. By explicitly specifying
                        a class name it is possible to group the declared queries).
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="singleRowQuery" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>
                        Indicates, whether the generated query is expected to return a single row only.
                        This will change the method return type from "java.util.List" to the respective
                        type (default is false).
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="acquireLock" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>
                        Indicates, whether NoORM should acquire a lock for the retrieved rows (by appending
                        the "FOR UPDATE" clause to the generated SQL).
                        Note that this option is only useful when used in an explicitly managed transaction
                        (user-managed), otherwise an exception is thrown.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="queryColumn">
        <xs:annotation>
            <xs:documentation>
                A query column is a WHERE condition consisting of a database column name from the used entity
                with an operator for the construction of the full WHERE condition.
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="name" use="required" type="xs:string"/>
        <xs:attribute name="operator" type="operatorName"/>
    </xs:complexType>

    <xs:simpleType name="operatorName">
        <xs:annotation>
            <xs:documentation>
                This enumeration is a predefined list of supported relational operators available for the
                construction of WHERE conditions. Note that the operators "IS_NULL" and "IS_NOT_NULL" are
                unary, i.e., they do not need the provision of a parameter to compare against (will be
                automatically reflected by the code generator).
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="EQUAL_TO"/>
            <xs:enumeration value="NOT_EQUAL_TO"/>
            <xs:enumeration value="GREATER_THAN"/>
            <xs:enumeration value="GREATER_THAN_OR_EQUAL_TO"/>
            <xs:enumeration value="LESS_THAN"/>
            <xs:enumeration value="LESS_THAN_OR_EQUAL_TO"/>
            <xs:enumeration value="LIKE"/>
            <xs:enumeration value="IS_NULL"/>
            <xs:enumeration value="IS_NOT_NULL"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="typeMappings">
        <xs:annotation>
            <xs:documentation>
                A list of custom type mappings (see type "customTypeMapping").
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="typeMapping" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="typeMapping">
        <xs:annotation>
            <xs:documentation>
                A single type mapping with its application scope.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="parameterFilterRegex" type="xs:string">
                <xs:annotation>
                    <xs:documentation>
                        The scope of the custom type mapping can be specified on a per parameter basis using
                        regular expressions to identify the parameter(s) for the application of the custom
                        type mapping..
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="tableFilterRegex" type="xs:string">
                <xs:annotation>
                    <xs:documentation>
                        The scope of the custom type mapping can be specified on a per table basis using
                        regular expressions to identify the table(s) for the application of the custom
                        type mapping.
                        To apply the specified type mapping to all tables (and columns), a wildcard
                        expression can be used (".*").
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="columnFilterRegex" type="xs:string">
                <xs:annotation>
                    <xs:documentation>
                        The scope of the custom type mapping can be specified on a per column basis using
                        regular expressions to identify the column(s) for the application of the custom
                        type mapping..
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="databaseType" type="xs:string" use="required">
                <xs:annotation>
                    <xs:documentation>
                        The database (source) type of the custom type mapping. This is the SQL standard or
                        vendor specific type declaration like "INTEGER" or "NUMBER". Note that only the base
                        type declaration is used to identify an attribute applicable for a custom type
                        mapping (e.g. fractions of numeric types are ignored, but through the usage of the
                        filter regex for tables and columns it is usually no problem to restrict the mapping
                        to the column(s) of choice).
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="javaType" type="javaType" use="required">
                <xs:annotation>
                    <xs:documentation>
                        The Java type for the custom type mapping (see enumeration "javaType")
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <xs:simpleType name="javaType">
        <xs:annotation>
            <xs:documentation>
                The Java (destination) type of a custom mapping. This is the type used in the generated
                Java code for bean attributes, enum attributes or service method parameters.
                Java types from package "java.lang.*" do not need to get fully specified (i.e., "Long",
                "Double", etc., is sufficient), other types must be fully specified
                (e.g. "java.math.BigDecimal").
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="String"/>
            <xs:enumeration value="Boolean"/>
            <xs:enumeration value="Long"/>
            <xs:enumeration value="Integer"/>
            <xs:enumeration value="Short"/>
            <xs:enumeration value="Byte"/>
            <xs:enumeration value="Float"/>
            <xs:enumeration value="Double"/>
            <xs:enumeration value="java.math.BigDecimal"/>
            <xs:enumeration value="java.util.Date"/>
            <xs:enumeration value="java.sql.Date"/>
            <xs:enumeration value="java.sql.Timestamp"/>
            <xs:enumeration value="java.sql.Clob"/>
            <xs:enumeration value="java.sql.NClob"/>
            <xs:enumeration value="java.sql.Blob"/>
            <xs:enumeration value="java.sql.SQLXML"/>
        </xs:restriction>
    </xs:simpleType>

</xs:schema>