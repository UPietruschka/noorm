<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns="http://www.noorm.org/generator-configuration/1.0.0"
           targetNamespace="http://www.noorm.org/generator-configuration/1.0.0"
           elementFormDefault="qualified"
           attributeFormDefault="unqualified">

    <xs:element name="generatorConfiguration">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="beanPackageName" type="xs:string">
                    <xs:annotation>
                        <xs:documentation>
                            Java package name for generated Bean source files.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="enumPackageName" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Java package name for generated Enum source files.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="servicePackageName" type="xs:string">
                    <xs:annotation>
                        <xs:documentation>
                            Java package name for generated Service / DAO source files.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="serviceInterfacePackageName" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Services, resp. DAOs generated by NoORM are singletons. By default, the services
                            or DAOs are instantiated right after class loading and provided by the class method
                            "getInstance".
                            Alternatively, class instantiation can be delegated to a dependency injection framework
                            like Spring. By specifying parameter serviceInterfacePackageName, the service generator
                            is directed to omit the in-class singleton implementation and generate appropriate
                            interfaces for every service, resp. DAO in the given package.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="beanTableFilterRegex" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Regular expression to filter tables and views for Bean generation.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="enumTableFilterRegex" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Regular expression to filter tables and views for Enum generation.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="packageFilterRegex" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Regular expression to filter (database) packages for service generation.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="table2SequenceMapping" type="propertyList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Primary key generation for new records being inserted into the database can be based
                            on a numeric ID column and an sequence. Sequences are not tied to a table
                            by definition, so associating a table with a sequence is done using this property
                            list. Note that the association TABLE_NAME/SEQUENCE_NAME can either be done on a per
                            table basis, or using one or more regular expressions to specify a mapping rule like
                            "TBL_(.*)" -> "SEQ_$1" (This rule would map TBL_PRODUCT to SEQ_PRODUCT, for example).
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="ignoreTableNamePrefixes" type="prefixList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            List of table name prefixes to be ignored for java class name construction.
                            Some data modelers use a common table name prefix to identify tables of a
                            given schema or group. When those prefixes are not desired in the constructed
                            java class name, they should be listed here.
                            This setting applies to the bean generator and the enum generator.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="ignoreColumnNamePrefixes" type="prefixList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            List of column name prefixes to be ignored for java method name construction.
                            Some data modelers use a common column name prefix to identify columns uniquely
                            for a given table. When those prefixes are not desired in the constructed
                            java method name, they should be listed here.
                            This setting applies to the bean generator and the enum generator.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="enumTable2DisplayColumnMapping" type="propertyList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            To generate Enums from database tables, NoORM must now, which table column should be
                            used for the enums constant type generation. Typically, a table with constant content
                            has a column with a code or denominator in uppercase letters, which uniquely
                            identifies the row.
                            Use this parameter to map tables, resp. views to this column name.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="optLockVersionColumnMapping" type="propertyList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Concurrency control can be based on optimistic locking. To identify the version column,
                            a mapping from the table-name to the version column should be specified. Dependent on
                            how specific the column-names are with respect to the table-names, one or more
                            mappings are required. In case of a unique name of the version column for all tables,
                            one simple rule like ".*" -> "VERSION" is sufficient.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="optLockFullRowCompareTableRegex" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Concurrency control can be based on optimistic locking.
                            When no version column is available for the tables subject to optimistic locking,
                            the complete pre-change image of the row is used to determine database changes, which
                            have occurred in the meantime. The tables listed here are subject to this type of
                            optimistic locking.
                            (Do not use both available types of optimistic locking simultaneously).
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="viewName2PrimaryKeyMapping" type="propertyList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The database metadata does not provide unambiguous information for the primary
                            key of a view (for tables, this information is available). When the intended use of a
                            view includes DML operations (which requires the view to contain one and only one
                            key-preserved table) or data access with the PageableBeanList, NoORM needs a key to
                            uniquely distinguish the records of this view.
                            Use this parameter to specify the column name of the key used for a given view.
                            Typically, this key is the primary key of the single key-preserved table contained in
                            the view definition.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="singleRowFinderRegex" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Using the signature of a stored procedure to generate code does not provide any hint,
                            if the returned data is limited to a single row (which in turn changes
                            the signature of the generated Java code, instead of a List a single Bean is returned).
                            Use this parameter to specify a regular expression matching all procedure names
                            subject to single row retrieval.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="pageableProcedureNameRegex" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Large query results can be mapped into a PageableBeanList to provide efficient
                            access to the data by loading the full record only for the requested page.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="extendedBeans" type="propertyList" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Beans generated from database entities are often subject to data enrichment in
                            the service layer utilizing the bean data. One option to add additional data to
                            the bean is the generic (generated) bean property "auxiliaryData". However, some
                            data consumers may require data provided in a flat bean without nested data
                            (i.e., the additional data is available using standard bean properties).
                            As an alternative approach to the auxiliary data property, the user may create
                            a subclass for the generated bean with additional bean properties. To utilize
                            this inherited bean classes, the generated services using the originally generated
                            class should use the subclass. This parameter allows to replace occurrences of the
                            originally generated bean classes in the generated services/DAOs with the subclass.
                            Note that the subclass must be fully classified.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="generatePKBasedEqualsAndHashCode" type="xs:boolean" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The implementation of methods "equals" and "hashCode" for the generated beans raises
                            the same questions intensively discussed for JPA entities. In particular, three options
                            are available: do not implement these methods at all, implement them based on the
                            technical ID, i.e. the primary key, or implement them based on some business-id.
                            The latter is not applicable for generated code, since we do not have the required
                            insight into the semantics of the bean/table to decide on a business-id.
                            Thus, options one and two remain and this option can be used to choose one. Note that
                            this option is set to true by default (i.e. methods equals and hashCode are
                            automatically implemented based on the primary key).
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="dataSourceName" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            When multiple data sources are used, the data source name as configured in the NoORM
                            configuration file is used to identify different data sources. To specify the data
                            source used for the subsequent statements, one can either set the data source explicitly
                            using DataSourceProvider.setActiveDataSource, or one can specify the data source name
                            here. Note that for explicit transaction handling, one still have to specify the data
                            source name.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="queryDeclarations" type="queryDeclarations" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The NoORM query declaration is intentionally much simpler than most other approaches
                            to specify alternatives to original SQL. While specifications like the JPA 2.0 criteria
                            API aim to cover most of the capabilities of SQL, this approach consequently follows
                            the paradigm to move database-centric functionality to the database.
                            In particular, this means that the complexity of an SQL statement should be implemented
                            inside the database using views. Following this approach, it is almost always possible
                            to reduce the query declaration for automatic Java code generation to a single entity
                            (table, view), the columns subject to the where-conditions (concatenated by "AND") and
                            the operators used for the columns in the where-conditions.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="customTypeMappings" type="customTypeMappings" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The Java code generator defines for every database type a default Java type, which is used in
                            the generated classes for attributes and method parameters (e.g. NUMBER -> java.lang.Long).
                            However, this mapping may not be suitable for certain situations. This configuration parameter
                            provides a flexible way to define custom type mappings.
                            Note that the database type depends on the database system and is not checked for validity, but
                            simply compared against the database types as retrieved from the database metadata. So, an
                            invalid database type has simply no effect.
                            The specified Java type however is checked for existence by the code generator, but not for
                            validity with respect to a proper data conversion in the JDBC driver used.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="prefixList">
        <xs:annotation>
            <xs:documentation>
                A list of database name prefixes to be trimmed for Java code generation.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="prefix" type="xs:string" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="queryDeclarations">
        <xs:annotation>
            <xs:documentation>
                A list of automatically generated query declarations.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="queryDeclaration" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="queryDeclaration">
        <xs:annotation>
            <xs:documentation>
                Query declarations provide a convenient and simple way to specify SQL queries without the need
                to explicitly write SQL code. However, query declarations are not designated to replace SQL code
                of arbitrary complexity, but only to provide an efficient method to specify rather primitive SQL
                queries using a single entity only and a list of WHERE conditions concatenated by "AND".
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="tableName" type="xs:string">
                    <xs:annotation>
                        <xs:documentation>
                            The name of the database entity (table or view) to query against.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="baseTable" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The name of the database entity (table or view), which is the base for the returning
                            type. When parameter "tableName" is a view, the desired return type may be only one of
                            the tables contained in the view.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="methodName" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The (Java) method name for the generated code (if omitted, NoORM automatically
                            generates a method name. This is typically suitable, if not too many query columns
                            are defined. For many query columns, manual method name specification if preferable).
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="className" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The name of the Java class to be generated (Optional, by default NoORM generates one
                            single class named "DeclaredQueries" for all declared queries. By explicitly specifying
                            a class name it is possible to group the declared queries).
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="singleRowQuery" type="xs:boolean" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Indicates, whether the generated query is expected to return a single row only.
                            This will change the method return type from "java.util.List" to the respective
                            type (default is false).
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="acquireLock" type="xs:boolean" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Indicates, whether NoORM should acquire a lock for the retrieved rows (by appending
                            the "FOR UPDATE" clause to the generated SQL).
                            Note that this option is only useful when used in an explicitly managed transaction
                            (user-managed), otherwise an exception is thrown.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="queryColumns" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            A list of query columns (WHERE conditions).
                        </xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="queryColumn" type="queryColumn" maxOccurs="unbounded"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="queryColumn">
        <xs:annotation>
            <xs:documentation>
                A query column is a WHERE condition consisting of a database column name from the used entity
                with an operator for the construction of the full WHERE condition.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="columnName" type="xs:string"/>
            <xs:element name="operator" type="operator" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="operator">
        <xs:annotation>
            <xs:documentation>
                The operator used for the construction of a WHERE condition.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="operatorName" type="operatorName"/>
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="operatorName">
        <xs:annotation>
            <xs:documentation>
                This enumeration is a predefined list of supported relational operators available for the
                construction of WHERE conditions. Note that the operators "IS_NULL" and "IS_NOT_NULL" are
                unary, i.e., they do not need the provision of a parameter to compare against (will be
                automatically reflected by the code generator).
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="EQUAL_TO"/>
            <xs:enumeration value="NOT_EQUAL_TO"/>
            <xs:enumeration value="GREATER_THAN"/>
            <xs:enumeration value="GREATER_THAN_OR_EQUAL_TO"/>
            <xs:enumeration value="LESS_THAN"/>
            <xs:enumeration value="LESS_THAN_OR_EQUAL_TO"/>
            <xs:enumeration value="LIKE"/>
            <xs:enumeration value="IS_NULL"/>
            <xs:enumeration value="IS_NOT_NULL"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="customTypeMappings">
        <xs:annotation>
            <xs:documentation>
                A list of custom type mappings (see type "customTypeMapping").
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="customTypeMapping" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="customTypeMapping">
        <xs:annotation>
            <xs:documentation>
                A single type mapping with its application scope.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="parameterFilterRegex" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The scope of the custom type mapping can be specified on a per parameter basis using
                            regular expressions to identify the parameter(s) for the application of the custom
                            type mapping..
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="tableFilterRegex" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The scope of the custom type mapping can be specified on a per table basis using
                            regular expressions to identify the table(s) for the application of the custom
                            type mapping.
                            To apply the specified type mapping to all tables (and columns), a wildcard
                            expression can be used (".*").
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="columnFilterRegex" type="xs:string" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            The scope of the custom type mapping can be specified on a per column basis using
                            regular expressions to identify the column(s) for the application of the custom
                            type mapping..
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="databaseType" type="xs:string">
                    <xs:annotation>
                        <xs:documentation>
                            The database (source) type of the custom type mapping. This is the SQL standard or
                            vendor specific type declaration like "INTEGER" or "NUMBER". Note that only the base
                            type declaration is used to identify an attribute applicable for a custom type
                            mapping (e.g. fractions of numeric types are ignored, but through the usage of the
                            filter regex for tables and columns it is usually no problem to restrict the mapping
                            to the column(s) of choice).
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="javaType" type="javaType">
                    <xs:annotation>
                        <xs:documentation>
                            The Java type for the custom type mapping (see enumeration "javaType")
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:simpleType name="javaType">
        <xs:annotation>
            <xs:documentation>
                The Java (destination) type of a custom mapping. This is the type used in the generated
                Java code for bean attributes, enum attributes or service method parameters.
                Java types from package "java.lang.*" do not need to get fully specified (i.e., "Long",
                "Double", etc., is sufficient), other types must be fully specified
                (e.g. "java.math.BigDecimal").
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="String"/>
            <xs:enumeration value="Boolean"/>
            <xs:enumeration value="Long"/>
            <xs:enumeration value="Integer"/>
            <xs:enumeration value="Short"/>
            <xs:enumeration value="Byte"/>
            <xs:enumeration value="Float"/>
            <xs:enumeration value="Double"/>
            <xs:enumeration value="java.math.BigDecimal"/>
            <xs:enumeration value="java.util.Date"/>
            <xs:enumeration value="java.sql.Date"/>
            <xs:enumeration value="java.sql.Timestamp"/>
            <xs:enumeration value="java.sql.Clob"/>
            <xs:enumeration value="java.sql.NClob"/>
            <xs:enumeration value="java.sql.Blob"/>
            <xs:enumeration value="java.sql.SQLXML"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="propertyList">
        <xs:sequence>
            <xs:element name="property" type="property" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="property">
        <xs:sequence>
            <xs:element name="name" type="xs:string"/>
            <xs:element name="value" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>

</xs:schema>