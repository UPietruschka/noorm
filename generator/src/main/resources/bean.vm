## Velocity template to generate Java Bean classes
package $class.PackageName;

import java.io.Serializable;
import java.sql.JDBCType;
import java.sql.Types;
import java.util.HashMap;
import org.noorm.jdbc.IBean;
import org.noorm.jdbc.JDBCColumn;

/**
 * Bean class for database table $class.TableName
 * DO NOT EDIT! This file has been auto-generated by NoORM
 */
public class $class.Name<T>#if($class.getSuperClassName()) extends $class.SuperClassName<T>#end implements IBean<T>, Serializable#if($class.getCustomInterfaceName()), $class.CustomInterfaceName#end {

#if(!$class.getSuperClassName())
	private static final long serialVersionUID = $class.getSerialVersionUID()L;
	protected static final String TABLE_NAME = "$class.TableName";
	protected static final boolean IS_TABLE_NAME_CASE_SENSITIVE = $class.isTableNameCaseSensitive();
	protected static final String[] PK_COLUMN_NAMES = { #foreach ($param in $class.PrimaryKeyColumnNames)"$param"#if($foreach.count<$class.PrimaryKeyColumnNames.size()), #end#end };
	protected static final String[] PK_JAVA_NAMES = { #foreach ($param in $class.PrimaryKeyJavaNames)"$param"#if($foreach.count<$class.PrimaryKeyJavaNames.size()), #end#end };
	protected static final String SEQUENCE_NAME = "$class.SequenceName";
	protected static final Long SEQUENCE_INCREMENT = $class.getSequenceIncrement()L;
	protected static final boolean USE_INLINE_SEQUENCE_VALUE_GENERATION = $class.useInlineSequenceValueGeneration();
	protected static final String VERSION_COLUMN_NAME = "$class.VersionColumnName";
	protected static final String VERSION_COLUMN_JAVA_NAME = "$class.VersionColumnJavaName";
#if (!$class.getVersionColumnType())
	protected static final JDBCType VERSION_COLUMN_TYPE = null;
#else
	protected static final JDBCType VERSION_COLUMN_TYPE = JDBCType.$class.VersionColumnType;
#end
#end
	@JDBCColumn(name=PAGING_TOTAL, dataType=Types.NUMERIC, insertable=false, updatable=false)
	protected Integer pagingTotal;
#foreach ($att in $class.Attributes)
#if (!$att.OmitSuperClassAttribute)
	@JDBCColumn(name="$att.ColumnName", dataType=$att.DataType#if(!$att.Insertable), insertable=false#end#if(!$att.Updatable), updatable=false#end#if(!$att.Nullable), nullable=false#end#if($att.CaseSensitiveName), caseSensitiveName=true#end#if($att.MaxLength>0), maxLength=$att.MaxLength#end)
	protected $att.Type $att.Name;
#end
#end
	private transient T auxiliaryData;
#if ($class.enableOptLockFullRowCompare())
#if(!$class.getSuperClassName())
	protected HashMap<String, Object> modifiedFieldsInitialValue = new HashMap<String, Object>();
#end
#end

    @Override
	public Integer getPagingTotal() {
	    return pagingTotal;
	}

    @Override
	public T getAuxiliaryData() {
		return auxiliaryData;
	}

    @Override
	public void setAuxiliaryData(final T pAuxiliaryData) {
		auxiliaryData = pAuxiliaryData;
	}

    @Override
	public HashMap<String, Object> getModifiedFieldsInitialValue() {
#if ($class.enableOptLockFullRowCompare())
		return modifiedFieldsInitialValue;
#else
		return null;
#end
	}

#if(!$class.getSuperClassName())
    @Override
	public String getTableName() {
		return TABLE_NAME;
	}

    @Override
	public boolean isTableNameCaseSensitive() {
		return IS_TABLE_NAME_CASE_SENSITIVE;
	}

    @Override
	public String[] getPrimaryKeyColumnNames() {
		return PK_COLUMN_NAMES;
	}

    @Override
	public String[] getPrimaryKeyJavaNames() {
		return PK_JAVA_NAMES;
	}

    @Override
	public String getSequenceName() {
		return SEQUENCE_NAME;
	}

    @Override
	public Long getSequenceIncrement() {
		return SEQUENCE_INCREMENT;
	}

    @Override
	public boolean useInlineSequenceValueGeneration() {
		return USE_INLINE_SEQUENCE_VALUE_GENERATION;
	}

    @Override
	public String getVersionColumnName() {
		return VERSION_COLUMN_NAME;
	}

    @Override
	public String getVersionColumnJavaName() {
		return VERSION_COLUMN_JAVA_NAME;
	}

    @Override
	public JDBCType getVersionColumnType() {
		return VERSION_COLUMN_TYPE;
	}
#end
#foreach ($att in $class.Attributes)
#if (!$att.OmitSuperClassAttribute)

	public $att.Type get$att.getMethodNamePostfix()() {
		return $att.Name;
	}

	public void set$att.getMethodNamePostfix()(final $att.Type p$att.getMethodNamePostfix()) {
#if ($class.enableOptLockFullRowCompare())
		if (!modifiedFieldsInitialValue.containsKey("$att.ColumnName")) {
			modifiedFieldsInitialValue.put("$att.ColumnName", $att.Name);
		}
#end
		$att.Name = p$att.getMethodNamePostfix();
	}
#end
#end
#if ($class.hasPrimaryKey())
#if ($class.generatePKBasedEqualsAndHashCode())

	@Override
	public boolean equals(final Object pObject) {
		if (this == pObject) return true;
		if (pObject == null || !(pObject instanceof $class.Name)) return false;
		if (#foreach ($param in $class.PrimaryKeyJavaNames)${param} == null#if($foreach.count<$class.PrimaryKeyJavaNames.size()) || #end#end) return false;
		final $class.Name other = ($class.Name) pObject;
		return #foreach ($param in $class.PrimaryKeyJavaNames)${param}.equals(other.${param})#if($foreach.count<$class.PrimaryKeyJavaNames.size()) && #end#end;
	}

	@Override
	public int hashCode() {
		if (#foreach ($param in $class.PrimaryKeyJavaNames)${param} == null#if($foreach.count<$class.PrimaryKeyJavaNames.size()) || #end#end) return super.hashCode();
		return #foreach ($param in $class.PrimaryKeyJavaNames)${param}.hashCode()#if($foreach.count<$class.PrimaryKeyJavaNames.size()) + #end#end;
	}
#end
#end
}