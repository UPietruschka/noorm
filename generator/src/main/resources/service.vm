## Velocity template to generate Java Service classes
package $class.PackageName;

import ${class.BeanPackageName}.*;
import org.noorm.jdbc.*;
import java.util.*;

/**
 * Service class for database package $class.DatabasePackageName
 * DO NOT EDIT! This file has been auto-generated by NoORM
 */
public class $class.JavaName {

	private static $class.JavaName $class.getFirstLowerName();
	private final JDBCStatementProcessor typelessStatementProcessor = JDBCStatementProcessor.getInstance();

	protected $class.getJavaName()() {
	}

	public static $class.JavaName getInstance() {

		synchronized (${class.getJavaName()}.class) {
			if ($class.getFirstLowerName() == null) {
				$class.getFirstLowerName() = new $class.getJavaName()();
			}
		}
		return $class.getFirstLowerName();
	}
#foreach ($proc in $class.Procedures)

#if($proc.isOutParamRefCursor())
#if($proc.isSingleRowFinder())
#set ($returnType = "$proc.getOutParamJavaType()")
#else
#set ($returnType = "List<$proc.getOutParamJavaType()>")
#end
#end
#if($proc.isOutParamScalar())
#set ($returnType = "$proc.getOutParamJavaType()")
#end
	public#if($proc.hasOutParam()) $returnType#else void#end $proc.getJavaName()(#foreach ($param in $proc.Parameters)final $param.JavaType ${param.JavaName}#if($velocityCount<$proc.Parameters.size()),${nl}${subindent}#end#end) {

#if($proc.isPageableFinder())
		return new PageableBeanList<${proc.getOutParamJavaType()}>
				($proc.Parameters[0].JavaName, "${class.DatabasePackageName}.$proc.OracleName", "$proc.OutParamOracleName", "$proc.Parameters[0].OracleName", ${proc.getOutParamJavaType()}.class);
#else
#if($proc.hasOutParam())
		final JDBCStatementProcessor<$proc.getOutParamJavaType()> statementProcessor = JDBCStatementProcessor.getInstance();
#end
		final Map<String, Object> filterParameters = new HashMap<String, Object>();
#foreach ($param in $proc.Parameters)
		filterParameters.put("${param.OracleName}", ${param.JavaName});
#end
#if($proc.isOutParamRefCursor())
#if($proc.isSingleRowFinder())
		return statementProcessor.getBeanFromPLSQL
#else
		return statementProcessor.getBeanListFromPLSQL
#end
				("${class.DatabasePackageName}.$proc.OracleName", "$proc.OutParamOracleName",
						filterParameters, ${proc.getOutParamJavaType()}.class);
#elseif($proc.isOutParamScalar())
		return statementProcessor.callPLSQL
				("${class.DatabasePackageName}.$proc.OracleName", "$proc.OutParamOracleName",
						filterParameters, ${proc.getOutParamJavaType()}.class);
#else
		typelessStatementProcessor.callPLSQL
				("${class.DatabasePackageName}.$proc.OracleName", filterParameters);
#end
#end
	}
#end
#foreach ($bean in $class.ReturnTypeShortNames)

	public $class.getReturnTypeBeanName($bean) insert$bean(final $class.getReturnTypeBeanName($bean) p${bean}) {
		final JDBCStatementProcessor<$class.getReturnTypeBeanName($bean)> statementProcessor = JDBCStatementProcessor.getInstance();
		return statementProcessor.insert(p${bean});
	}

	public void insert${bean}List(final List<$class.getReturnTypeBeanName($bean)> p${bean}List) {
		typelessStatementProcessor.insert(p${bean}List);
	}

	public void update$bean(final $class.getReturnTypeBeanName($bean) p${bean}) {
		typelessStatementProcessor.update(p${bean});
	}

	public void update${bean}List(final List<$class.getReturnTypeBeanName($bean)> p${bean}List) {
		typelessStatementProcessor.update(p${bean}List);
	}

	public void delete$bean(final $class.getReturnTypeBeanName($bean) p${bean}) {
		typelessStatementProcessor.delete(p${bean});
	}

	public void delete${bean}List(final List<$class.getReturnTypeBeanName($bean)> p${bean}List) {
		typelessStatementProcessor.delete(p${bean}List);
	}
#end
}