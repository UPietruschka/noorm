## Velocity template to generate Java Service classes
#if($class.isInterface())
package $class.InterfacePackageName;
#else
package $class.PackageName;
#end

import ${class.BeanPackageName}.*;
import org.noorm.jdbc.*;
import java.util.*;
#if(!$class.isInterface() && $class.hasInterface())
import ${class.InterfacePackageName}.${class.JavaInterfaceName};
#end

/**
 * Service class for database package $class.DatabasePackageName
 * DO NOT EDIT! This file has been auto-generated by NoORM
 */
#if($class.isInterface())
public interface $class.JavaInterfaceName {
#else
#if($class.hasInterface())
public class $class.JavaName implements IService, $class.JavaInterfaceName {
#else
public class $class.JavaName implements IService {
#end
#end

#if(!$class.isInterface())
	private static final int CODE_HASH_VALUE = $class.CodeHashValue;
	private static final String DATABASE_PACKAGE_NAME = "$class.DatabasePackageName";
	private final JDBCStatementProcessor typelessStatementProcessor = JDBCStatementProcessor.getInstance();
#if(!$class.hasInterface())
	private static $class.JavaName $class.getFirstLowerName() = new $class.getJavaName()();
#end

#end
	/**
	 * Returns the PL/SQL package name, the generated Java Service is based on.
	 * @return the PL/SQL package name.
	 */
#if($class.isInterface())
	String getDatabasePackageName();
#else
	public String getDatabasePackageName() {
		return DATABASE_PACKAGE_NAME;
	}
#end

	/**
	 * Validation of the generated service against the database is performed using a hash value calculated on
	 * basis of the full text of the PL/SQL package body used for this service.
	 * @return the calculated, reproducible hash value.
	 */
#if($class.isInterface())
	int getCodeHashValue();
#else
	public int getCodeHashValue() {
		return CODE_HASH_VALUE;
	}

#end
#if(!$class.isInterface() && !$class.hasInterface())
	protected $class.getJavaName()() {
	}

	public static $class.JavaName getInstance() {

		return $class.getFirstLowerName();
	}
#end
#foreach ($proc in $class.Procedures)

#if($proc.isOutParamRefCursor())
#if($proc.isSingleRowFinder())
#set ($returnType = "$proc.getOutParamJavaType()")
#else
#set ($returnType = "List<$proc.getOutParamJavaType()>")
#end
#end
#if($proc.isOutParamScalar())
#set ($returnType = "$proc.getOutParamJavaType()")
#end
#if($class.isInterface())
	#if($proc.hasOutParam())$returnType#else void#end $proc.getJavaName()(#foreach ($param in $proc.Parameters)final $param.JavaType ${param.JavaName}#if($velocityCount<$proc.Parameters.size()),${nl}${subindent}#end#end);
#else
	public#if($proc.hasOutParam()) $returnType#else void#end $proc.getJavaName()(#foreach ($param in $proc.Parameters)final $param.JavaType ${param.JavaName}#if($velocityCount<$proc.Parameters.size()),${nl}${subindent}#end#end) {

#if($proc.isPageableFinder())
		return new PageableBeanList<${proc.getOutParamJavaType()}>
				($proc.Parameters[0].JavaName, "${class.DatabasePackageName}.$proc.OracleName", "$proc.OutParamOracleName", "$proc.Parameters[0].OracleName", ${proc.getOutParamJavaType()}.class);
#else
#if($proc.hasOutParam())
		final JDBCStatementProcessor<$proc.getOutParamJavaType()> statementProcessor = JDBCStatementProcessor.getInstance();
#end
		final Map<String, Object> filterParameters = new HashMap<String, Object>();
#foreach ($param in $proc.Parameters)
		filterParameters.put("${param.OracleName}", ${param.JavaName});
#end
#if($proc.isOutParamRefCursor())
#if($proc.isSingleRowFinder())
		return statementProcessor.getBeanFromPLSQL
#else
		return statementProcessor.getBeanListFromPLSQL
#end
				("${class.DatabasePackageName}.$proc.OracleName", "$proc.OutParamOracleName",
						filterParameters, ${proc.getOutParamJavaType()}.class);
#elseif($proc.isOutParamScalar())
		return statementProcessor.callPLSQL
				("${class.DatabasePackageName}.$proc.OracleName", "$proc.OutParamOracleName",
						filterParameters, ${proc.getOutParamJavaType()}.class);
#else
		typelessStatementProcessor.callPLSQL
				("${class.DatabasePackageName}.$proc.OracleName", filterParameters);
#end
#end
	}
#end
#end
#foreach ($bean in $class.ReturnTypeShortNames)

#if($class.isInterface())
	$class.getReturnTypeBeanName($bean) insert$bean(final $class.getReturnTypeBeanName($bean) p${bean});

	void insert${bean}List(final List<$class.getReturnTypeBeanName($bean)> p${bean}List);

	void update$bean(final $class.getReturnTypeBeanName($bean) p${bean});

	void update${bean}List(final List<$class.getReturnTypeBeanName($bean)> p${bean}List);

	void delete$bean(final $class.getReturnTypeBeanName($bean) p${bean});

	void delete${bean}List(final List<$class.getReturnTypeBeanName($bean)> p${bean}List);
#else
	public $class.getReturnTypeBeanName($bean) insert$bean(final $class.getReturnTypeBeanName($bean) p${bean}) {
		final JDBCStatementProcessor<$class.getReturnTypeBeanName($bean)> statementProcessor = JDBCStatementProcessor.getInstance();
		return statementProcessor.insert(p${bean});
	}

	public void insert${bean}List(final List<$class.getReturnTypeBeanName($bean)> p${bean}List) {
		typelessStatementProcessor.insert(p${bean}List);
	}

	public void update$bean(final $class.getReturnTypeBeanName($bean) p${bean}) {
		typelessStatementProcessor.update(p${bean});
	}

	public void update${bean}List(final List<$class.getReturnTypeBeanName($bean)> p${bean}List) {
		typelessStatementProcessor.update(p${bean}List);
	}

	public void delete$bean(final $class.getReturnTypeBeanName($bean) p${bean}) {
		typelessStatementProcessor.delete(p${bean});
	}

	public void delete${bean}List(final List<$class.getReturnTypeBeanName($bean)> p${bean}List) {
		typelessStatementProcessor.delete(p${bean}List);
	}
#end
#end
}