## Velocity template to generate Java Service classes
#if($class.isInterface())
package $class.InterfacePackageName;
#else
package $class.PackageName;
#end

import ${class.BeanPackageName}.*;
#if(!$class.isInterface())
import org.noorm.jdbc.*;
#end
import java.util.*;
#if(!$class.isInterface() && $class.hasInterface())
import ${class.InterfacePackageName}.${class.JavaInterfaceName};
#end

/**
 * Service class for database package $class.DatabasePackageName
 * DO NOT EDIT! This file has been auto-generated by NoORM
 */
#if($class.isInterface())
public interface $class.JavaInterfaceName {
#else
#if($class.hasInterface())
public class $class.JavaName implements IService, $class.JavaInterfaceName {
#else
public class $class.JavaName implements IService {
#end
#end

#if(!$class.isInterface())
#if ($class.hasDataSourceName())
	private static final String DATA_SOURCE_NAME = "$class.getDataSourceName()";
#end
	private static final int CODE_HASH_VALUE = $class.CodeHashValue;
	private static final String DATABASE_PACKAGE_NAME = "$class.DatabasePackageName";
	private final JDBCProcedureProcessor typelessProcedureProcessor = JDBCProcedureProcessor.getInstance();
#if(!$class.hasInterface())
	private static $class.JavaName $class.getFirstLowerName() = new $class.getJavaName()();
#end

#end
	/**
	 * Returns the PL/SQL package name, the generated Java Service is based on.
	 * @return the PL/SQL package name.
	 */
#if($class.isInterface())
	String getDatabasePackageName();
#else
	public String getDatabasePackageName() {
		return DATABASE_PACKAGE_NAME;
	}
#end

	/**
	 * Validation of the generated service against the database is performed using a hash value calculated on
	 * basis of the full text of the PL/SQL package body used for this service.
	 * @return the calculated, reproducible hash value.
	 */
#if($class.isInterface())
	int getCodeHashValue();
#else
	public int getCodeHashValue() {
		return CODE_HASH_VALUE;
	}

#end
#if(!$class.isInterface() && !$class.hasInterface())
	protected $class.getJavaName()() {
	}

	public static $class.JavaName getInstance() {

		return $class.getFirstLowerName();
	}
#end
#foreach ($proc in $class.Procedures)

#if($proc.isOutParamRefCursor())
#if($proc.isSingleRowFinder())
#set ($returnType = "$proc.getOutParamJavaType()")
#else
#set ($returnType = "List<$proc.getOutParamJavaType()>")
#end
#end
#if($proc.isOutParamScalar())
#set ($returnType = "$proc.getOutParamJavaType()")
#end
#if($class.isInterface())
	#if($proc.hasOutParam())$returnType#else void#end $proc.getJavaName()(#foreach ($param in $proc.Parameters)final $param.JavaType ${param.JavaName}#if($foreach.count<$proc.Parameters.size()),${nl}${subindent}#end#end);
#else
	public#if($proc.hasOutParam()) $returnType#else void#end $proc.getJavaName()(#foreach ($param in $proc.Parameters)final $param.JavaType ${param.JavaName}#if($foreach.count<$proc.Parameters.size()),${nl}${subindent}#end#end) {

#if ($class.hasDataSourceName())
		DataSourceProvider.setActiveDataSource(DATA_SOURCE_NAME);
#end
#if($proc.isPageableFinder())
		return new PageableBeanList<${proc.getOutParamJavaType()}>
				($proc.Parameters[0].JavaName, "${class.DatabasePackageName}.$proc.DbProcedureName", "$proc.OutDbParamName", "$proc.Parameters[0].DbParamName", ${proc.getOutParamJavaType()}.class);
#else
#if($proc.hasOutParam())
		final JDBCProcedureProcessor<$proc.getOutParamJavaType()> procedureProcessor = JDBCProcedureProcessor.getInstance();
#end
		final Map<String, Object> filterParameters = new HashMap<String, Object>();
#foreach ($param in $proc.Parameters)
		filterParameters.put("${param.getDbParamName()}", ${param.getJavaName()});
#end
#if($proc.isOutParamRefCursor())
#if($proc.isSingleRowFinder())
		return procedureProcessor.getBeanFromProcedure
#else
		return procedureProcessor.getBeanListFromProcedure
#end
				("${class.DatabasePackageName}.$proc.DbProcedureName", "$proc.OutDbParamName",
						filterParameters, ${proc.getOutParamJavaType()}.class);
#elseif($proc.isOutParamScalar())
		return procedureProcessor.callProcedure
				("${class.DatabasePackageName}.$proc.DbProcedureName", "$proc.OutDbParamName",
						filterParameters, ${proc.getOutParamJavaType()}.class);
#else
		typelessProcedureProcessor.callProcedure
				("${class.DatabasePackageName}.$proc.DbProcedureName", filterParameters);
#end
#end
	}
#end
#end
}